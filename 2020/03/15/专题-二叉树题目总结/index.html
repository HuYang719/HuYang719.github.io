<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Lucyyang在 Github 上的个人博客">
    <meta name="keyword" content="">
    <meta name="theme-color" content="#600090">
    <meta name="msapplication-navbutton-color" content="#600090">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="#600090">
    <link rel="shortcut icon" href="http://lucyyang719.com/img/saberQ4.jpg">
    <link rel="alternate" type="application/atom+xml" title="Lucyyang" href="/atom.xml">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.css">
    <title>
        
        专题: 二叉树题目总结｜Lucyyang&#39;s blog
        
    </title>

    <link rel="canonical" href="http://lucyyang719.com/2020/03/15/专题-二叉树题目总结/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/blog-style.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<style>

    header.intro-header {
        background-image: url('http://lucyyang719.com/img/banner.jpg')
    }
</style>
<!-- hack iOS CSS :active style -->
<body ontouchstart="" class="animated fadeIn">
<!-- hexo-inject:begin --><!-- hexo-inject:end --><!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top " id="nav-top" data-ispost = "true" data-istags="false
" data-ishome = "false" >
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand animated pulse" href="/">
                <span class="brand-logo">
                    Lucyyang
                </span>
                's Blog
            </a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <!-- /.navbar-collapse -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
					
                    
                        
                    
                        
                    
                        
							
                        <li>
                            <a href="/Archive/">Archive</a>
                        </li>
							
						
                    
                        
							
                        <li>
                            <a href="/About/">About</a>
                        </li>
							
						
                    
                        
							
                        <li>
                            <a href="/Tags/">Tags</a>
                        </li>
							
						
                    
                        
							
                        <li>
                            <a href="/Talks/">Talks</a>
                        </li>
							
						
                    
                        
                    
					
					
                </ul>
            </div>
        </div>
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
//    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>

<!-- Main Content -->

<!--only post-->


<img class="wechat-title-img"
     src="http://lucyyang719.com/img/banner.jpg">


<style>
    
    header.intro-header {
        background-image: url('http://lucyyang719.com/img/banner.jpg')
    }

    
</style>

<header class="intro-header">
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      <!--$表示行内元素，$$表示块状元素 -->
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    },
    "HTML-CSS": { availableFonts: ["TeX"] }
  });
</script>
<!--加载MathJax的最新文件， async表示异步加载进来 -->
<script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js">
</script>

    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <div class="post-heading">
                    <h1>专题: 二叉树题目总结</h1>
                    
                    <span class="meta">
                         作者 Lucyyang
                        <span>
                          日期 2020-03-15
                         </span>
                    </span>
                    <div class="tags text-center">
                        
                        <a class="tag" href="/tags/#算法"
                           title="算法">算法</a>
                        
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="post-title-haojen">
        <span>
            专题: 二叉树题目总结
        </span>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <!-- Post Container -->
            <div class="col-lg-8 col-lg-offset-1 col-sm-9 post-container">
                <blockquote>
<p>忘记昨天，也不要痴想明天。</p>
</blockquote>
<p>看了<a href="https://labuladong.gitbook.io/algo/shu-ju-jie-gou-xi-lie/xue-xi-shu-ju-jie-gou-he-suan-fa-de-gao-xiao-fang-fa" target="_blank" rel="external">学习算法和刷题的思路指南</a>中的第四部分，其实很多比较难一点的算法问题，本质上都是树的问题。好好练习树可以对后面解体有很大的帮助。</p>
<p>所以，很开心能开始总结二叉树专题啦！因为递归对我来说是薄弱环节，二叉树的一些题目对我还是颇有难度的。从我自己做题的经验，二叉树的题目基本可以分为用BFS和DFS进行递归解决。下面就从易到难总结一下做过的一些典型题目。</p>
<p>树的定义如下：
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">//Definition for a binary tree node.</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> val;</div><div class="line">    TreeNode *left;</div><div class="line">    TreeNode *right;</div><div class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>首先给出一个简单基本框架吧：
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">    <span class="comment">// 前序遍历</span></div><div class="line">    traverse(root.left)</div><div class="line">    <span class="comment">// 中序遍历</span></div><div class="line">    traverse(root.right)</div><div class="line">    <span class="comment">// 后序遍历</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在对应的注释那对root进行处理就对应着这种遍历方式。</p>
<h2>树的遍历</h2>
<p>首先来看和树的遍历相关的部分，最简单的就是直接给出一种遍历方式：</p>
<h3>Binary Tree Inorder Traversal</h3>
<p>题目: <a href="https://leetcode.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="external">LC94</a>，给定一棵二叉树，按中序遍历返回节点值。</p>
<p>方法: 最直接的做法就是递归，按照左根右的顺序进行遍历。</p>
<p>代码:
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inoder</span><span class="params">(TreeNode* root)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        inoder(root-&gt;left);</div><div class="line">        res.push_back(root-&gt;val);</div><div class="line">        inoder(root-&gt;right);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</div><div class="line">        inoder(root);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>相似的题目还有<a href="https://leetcode.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="external">前序遍历</a>，<a href="https://leetcode.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="external">后序遍历</a>。</p>
<h3>Binary Tree Level Order Traversal</h3>
<p>题目：<a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="external">L102</a>，还有一类典型的遍历方式是按层遍历。</p>
<p>方法：使用queue来保存树的节点，对于每一次的循环来说，可以先获得queue中的节点数，就是该层的nodes。</p>
<p>代码：
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</div><div class="line">       <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(<span class="number">0</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">0</span>));</div><div class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</div><div class="line">        q.push(root);</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</div><div class="line">        </div><div class="line">        TreeNode* cur = <span class="literal">nullptr</span>;</div><div class="line">        <span class="keyword">while</span>(!q.empty())&#123;</div><div class="line">            <span class="keyword">int</span> s = q.size();</div><div class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s;i++)&#123;</div><div class="line">                cur = q.front();</div><div class="line">                q.pop();</div><div class="line">                temp.push_back(cur-&gt;val);</div><div class="line">                <span class="keyword">if</span>(cur-&gt;left)</div><div class="line">                    q.push(cur-&gt;left);</div><div class="line">                <span class="keyword">if</span>(cur-&gt;right)</div><div class="line">                    q.push(cur-&gt;right);</div><div class="line">            &#125;</div><div class="line">            res.push_back(temp);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>还有类似的对N叉树进行层遍历，参见<a href="https://leetcode.com/problems/n-ary-tree-level-order-traversal/" target="_blank" rel="external">LC429</a>。</p>
<h3>Vertical Order Traversal of a Binary Tree</h3>
<p>题目：<a href="https://leetcode.com/problems/binary-tree-vertical-order-traversal/" target="_blank" rel="external">LC314</a>
遍历方式还有一种题目，按照垂直方式打印节点。</p>
<p>方法：依然按照层的方式进行遍历，但是有个小trick：<em><em>queue中存储的为pair&lt;int, TreeNode</em>&gt;，用于记录竖直方向上的level id</em>*。此外用一个map将不同的level id和值的集合关联起来。注意map有自动排序的特点。</p>
<p>代码:
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; verticalOrder(TreeNode* root) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</div><div class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</div><div class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; m;  <span class="comment">//此处注意Map自动排序的特性</span></div><div class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, TreeNode*&gt;&gt; q;</div><div class="line">        q.push(&#123;<span class="number">0</span>, root&#125;);</div><div class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</div><div class="line">            <span class="keyword">auto</span> a = q.front();</div><div class="line">            q.pop();</div><div class="line">            m[a.first].push_back(a.second-&gt;val); <span class="comment">// m[id] means the same level</span></div><div class="line">            <span class="keyword">if</span>(a.second-&gt;left) q.push(&#123;a.first<span class="number">-1</span>, a.second-&gt;left&#125;);</div><div class="line">            <span class="keyword">if</span>(a.second-&gt;right) q.push(&#123;a.first+<span class="number">1</span>, a.second-&gt;right&#125;);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a: m) &#123;</div><div class="line">            res.push_back(a.second); <span class="comment">//a is new variable，m已经根据key自动排序了</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>类似题目还有<a href="https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/" target="_blank" rel="external">LC987</a>。</p>
<h2>构建二叉树</h2>
<p>接下来难度升级，给定前序中序，让生成出二叉树：</p>
<h3>Construct Binary Tree I</h3>
<p>题目: <a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="external">LC105</a>，给定前序中序遍历，构造出一棵二叉树。</p>
<p>方法: 首先我们能知道前序遍历数组的第一个节点preorder[0]一定是树的根节点，而且也一定在inorder数组中存在，那就假设成preorder[0] = inoder[k]好了。而中序遍历最大的特点就是从根节点开始将左右子树分开，即<strong>k左边的就是根节点左子树的中序遍历、k右边的就是根节点右子树的中序遍历</strong>。这样我们也知道了根节点左子树的个数，即从0到k-1，右子树为k+1到inorder数组末尾。则对于preorder，从preorder[1]到preorder[k+1]都是该树的左子树，剩下的最后一部分就是根节点右子树的前序遍历。接下来就是分治的思想，将规模较大的问题分解成为两个较小的问题，然后递归的进行处理，还原左子树和右子树，最后连通根节点一起组成一棵完整的树。</p>
<p>代码：
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">TreeNode* <span class="title">divide</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder,</span></span></div><div class="line"><span class="function"><span class="params">    	<span class="keyword">int</span> lp,<span class="keyword">int</span> rp,<span class="keyword">int</span> li,<span class="keyword">int</span> ri)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(lp&gt;rp) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(preorder[lp]); <span class="comment">//建立根节点</span></div><div class="line">        <span class="comment">// find in inorder [li,ri]</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=li; i&lt;=ri;i++)&#123;</div><div class="line">        	<span class="comment">// 寻找中序遍历中根节点的位置，这样才能知道左右子树个数</span></div><div class="line">            <span class="keyword">if</span>(inorder[i]==preorder[lp])&#123; </div><div class="line"></div><div class="line">                <span class="comment">// 已知root在inorder中位置为i，则左子树有i-1-li+1(包含i-1和li，要加1)个元素</span></div><div class="line">                <span class="comment">// 而preorder从lp+1算起的i-li个元素</span></div><div class="line">                root-&gt;left = divide(preorder,inorder,lp+<span class="number">1</span>,lp+i-li,li,i<span class="number">-1</span>); </div><div class="line">                root-&gt;right = divide(preorder,inorder, lp+i-li+<span class="number">1</span>,rp,i+<span class="number">1</span>,ri);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> divide(preorder,inorder,<span class="number">0</span>,<span class="keyword">int</span>(preorder.size())<span class="number">-1</span>,<span class="number">0</span>,<span class="keyword">int</span>(inorder.size())<span class="number">-1</span>);</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3>Construct Binary Tree II</h3>
<p>题目：<a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="external">LC106</a>，接下来稍作变形，给定中序遍历和后序遍历，构建二叉树。</p>
<p>方法：和上述方法类似，只是对于后序遍历，根节点放在最后，因此更新左右子树时需要注意数组边界范围。</p>
<p>代码：
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>: </div><div class="line">    <span class="function">TreeNode* <span class="title">divide</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder, <span class="keyword">int</span> li, <span class="keyword">int</span> ri, <span class="keyword">int</span> lp, <span class="keyword">int</span> rp)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(lp&gt;rp) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        TreeNode* node = <span class="keyword">new</span> TreeNode(postorder[rp]);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=li;i&lt;=ri;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(inorder[i]==postorder[rp])&#123;</div><div class="line">                </div><div class="line">                node-&gt;left = divide(inorder,postorder,li,i<span class="number">-1</span>,lp,lp+i-li<span class="number">-1</span>);</div><div class="line">                node-&gt;right = divide(inorder,postorder,i+<span class="number">1</span>,ri,lp+i-li,rp<span class="number">-1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> node; </div><div class="line">    &#125;</div><div class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> divide(inorder,postorder,<span class="number">0</span>,<span class="keyword">int</span>(inorder.size())<span class="number">-1</span>,<span class="number">0</span>,<span class="keyword">int</span>(postorder.size())<span class="number">-1</span>);</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3>Convert Sorted Array to BST</h3>
<p>题目：<a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="external">LC108</a>，将有序数组转为二叉搜索树，即保证所有左子树的值比root-&gt;val小，所有右子树的值比root-&gt;val大。</p>
<p>方法：对于这道题的核心，就是要找到一个根节点，使得全部左子树值比它小，全部右子树值比它大，那哪一个数最合适呢？当然是数组的中间数，将中间数构建成根节点后，左子树则通过数组前半部分构建，右子树通过数组后半部分构建。</p>
<p>代码：
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">TreeNode*  <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">      <span class="keyword">if</span>(start&gt;end) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">      TreeNode* root = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</div><div class="line">      </div><div class="line">	  <span class="keyword">int</span> mid = start + (start-end)/<span class="number">2</span>;</div><div class="line">	  root-&gt;val = nums[mid];</div><div class="line">	  root-&gt;left = buildTree(nums,start,mid<span class="number">-1</span>);</div><div class="line">	  root-&gt;right = buildTree(nums,mid+<span class="number">1</span>,end);</div><div class="line">      </div><div class="line">      <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span>(nums.empty()==<span class="literal">true</span>) &#123;<span class="keyword">return</span> <span class="literal">NULL</span>;&#125;</div><div class="line">      TreeNode* root;</div><div class="line">      root = buildTree(nums,<span class="number">0</span>,<span class="keyword">int</span>(nums.size())<span class="number">-1</span>);</div><div class="line">      <span class="keyword">return</span> root;    </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这道题在周赛180第三题中有个follow up，<a href="http://lucyyang719.com/2020/03/15/LeetCode%E5%91%A8%E8%B5%9B180/">如何将二叉搜索树构建成平衡二叉搜索树</a>。</p>
<h3>Recover Binary Search Tree</h3>
<p>题目：<a href="https://leetcode.com/problems/recover-binary-search-tree/" target="_blank" rel="external">LC99</a>，要求不改变树的结构，返回一个搜索二叉树。</p>
<p>方法：这题有个小trick，中序遍历的时候将节点也保存在vector中，然后将值进行排序。再对节点一一赋值，这样最先被赋值的就是左子树，也就是最小值，中间root被赋予中间的数值，右子树会被赋予数组后半部分较大的值。</p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vals;</div><div class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; nodes;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        inorder(root-&gt;left);</div><div class="line">        vals.push_back(root-&gt;val);</div><div class="line">        nodes.push_back(root);</div><div class="line">        inorder(root-&gt;right);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        inorder(root);</div><div class="line">        sort(vals.begin(), vals.end());</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes.size(); i++) &#123;</div><div class="line">            nodes[i]-&gt;val = vals[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3>Unique Binary Search Trees</h3>
<p>题目：<a href="https://leetcode.com/problems/unique-binary-search-trees-ii/" target="_blank" rel="external">L95</a>，TODO</p>
<h2>树的判定</h2>
<p>这类题目主要是来判断树的特性。</p>
<h3>Same Tree</h3>
<p>题目：<a href="https://leetcode.com/problems/same-tree/" target="_blank" rel="external">L100</a>，判断两棵树是否相同。</p>
<p>方法：递归check，每次检查nodes都存在并且值相等，否则返回false。</p>
<p>代码：
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(p==<span class="literal">NULL</span>&amp;&amp;q==<span class="literal">NULL</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p==<span class="literal">NULL</span>||q==<span class="literal">NULL</span>)&#123;</div><div class="line">            <span class="comment">// 上一个已经判断了p是NULL还是q是NULL</span></div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;val!=q-&gt;val)</div><div class="line">        	<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">return</span> isSameTree(p-&gt;left,q-&gt;left)&amp;&amp;isSameTree(p-&gt;right,q-&gt;right); </div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3>Validate Binary Search Tree</h3>
<p>题目：<a href="https://leetcode.com/problems/validate-binary-search-tree/" target="_blank" rel="external">L98</a>判断一棵树是否为二叉搜索树。</p>
<p>方法：设立下限和上限，每次判断节点值是否在上下限之内，对于左右子树分别更新上下界限。如果左右子树都为true，该节点返回true。</p>
<p>代码：
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode* node, <span class="keyword">int</span> lower_limit, <span class="keyword">int</span> upper_limit)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(node==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        <span class="keyword">if</span>((lower_limit!=<span class="number">-1</span>)  &amp;&amp; (node-&gt;val &lt;=lower_limit))</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">if</span>((upper_limit!=<span class="number">-1</span>)&amp;&amp;(upper_limit&lt;=node-&gt;val))</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">bool</span> left = node-&gt;left!=<span class="literal">NULL</span>? helper(node-&gt;left,lower_limit,node-&gt;val):<span class="literal">true</span>;</div><div class="line">        <span class="keyword">bool</span> right=node-&gt;right!=<span class="literal">NULL</span>? helper(node-&gt;right,node-&gt;val,upper_limit):<span class="literal">true</span>;</div><div class="line">        <span class="keyword">return</span> left&amp;&amp;right;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        <span class="keyword">return</span> helper(root,<span class="number">-1</span>,<span class="number">-1</span>);</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3>Check Completeness of a Binary Tree</h3>
<p>题目：<a href="https://leetcode.com/problems/check-completeness-of-a-binary-tree/" target="_blank" rel="external">LC958</a>，检查一棵树的完整性，即左子树为空的情况下，右子树不可有值。</p>
<p>方法：这题的关键在于设置一个bool seennull，然后按层遍历。对于每层的节点，如果左子树为空，则seennull为true，如果之后右子树不为空，则返回false。这题的做法还可以进一步简化，树的完整性其实就是中间不能出先null节点，如果一旦出现null节点，我们将seennull设为true，如果之后发现还有节点，则返回false。这样就不用考虑每层的节点问题了。</p>
<p>代码:
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isCompleteTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; que;</div><div class="line">        que.push(root);</div><div class="line">        <span class="keyword">bool</span> seennull = <span class="literal">false</span>; <span class="comment">//这个是判断的一个关键</span></div><div class="line">        <span class="keyword">while</span>(!que.empty()) &#123;</div><div class="line">            TreeNode *cur = que.front();</div><div class="line">            que.pop();</div><div class="line">            <span class="keyword">if</span>(cur == <span class="literal">NULL</span>) &#123;</div><div class="line">                <span class="keyword">if</span>(!seennull) seennull = <span class="literal">true</span>;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">//cur != NULL</span></div><div class="line">                <span class="keyword">if</span>(seennull == <span class="literal">true</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            &#125;</div><div class="line">            que.push(cur-&gt;left); <span class="comment">//if left is null, push null and check in the next //round, if we found it is null, seennull = true. if right is not null, return //false.</span></div><div class="line">            que.push(cur-&gt;right);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>

                <hr>
                

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2020/03/15/LeetCode周赛180/" data-toggle="tooltip" data-placement="top"
                           title="LeetCode周赛180">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2020/03/14/采用LLVM构建语言编译器/" data-toggle="tooltip" data-placement="top"
                           title="采用LLVM构建语言编译器">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                

                


                <!--加入新的评论系统-->
                
                <!-- 来必力City版安装代码 -->
                    <div id="lv-container" data-id="city" data-uid="MTAyMC8zMDA0OS82NjEz">
                    <script type="text/javascript">
                       (function(d, s) {
                           var j, e = d.getElementsByTagName(s)[0];

                           if (typeof LivereTower === 'function') { return; }

                           j = d.createElement(s);
                           j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                           j.async = true;

                           e.parentNode.insertBefore(j, e);
                       })(document, 'script');
                    </script>
                    <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
                    </div>
<!-- City版安装代码已完成 -->
                
            </div>

            <div class="hidden-xs col-sm-3 toc-col">
                <div class="toc-wrap">
                    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-text">树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-text">Binary Tree Inorder Traversal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-text">Binary Tree Level Order Traversal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-text">Vertical Order Traversal of a Binary Tree</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-text">构建二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-text">Construct Binary Tree I</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-text">Construct Binary Tree II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-text">Convert Sorted Array to BST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-text">Recover Binary Search Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-text">Unique Binary Search Trees</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-text">树的判定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-text">Same Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-text">Validate Binary Search Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-text">Check Completeness of a Binary Tree</span></a></li></ol></li></ol>
                </div>
            </div>
        </div>

        <div class="row">
            <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5 class="text-center">
                        <a href="/tags/">FEATURED TAGS</a>
                    </h5>
                    <div class="tags">
                        
                        <a class="tag" href="/tags/#算法"
                           title="算法">算法</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <div style="margin-top: 20px;">
                    <h5 class="text-center">FRIENDS</h5>
                    <ul class="list-inline text-center">
                        
                        <li><a href="http://blog.nebula.moe/">nebula</a></li>
                        
                        <li><a href="http://chengpeng.space/">ChengPeng</a></li>
                        
                        <li><a href="https://ring0.me/">boj</a></li>
                        
                        <li><a href="https://sd-invol.github.io">轩</a></li>
                        
                    </ul>
                </div>
                
            </div>
        </div>

    </div>
</article>







<!-- Footer -->
<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <br>
                <ul class="list-inline text-center">
                
                
                

                

                

                
                
                <!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->

                
                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Lucyyang 2020
                    <br>
                    <span id="busuanzi_container_site_pv" style="font-size: 12px;">PV: <span id="busuanzi_value_site_pv"></span> Times</span>
                    <br>
                   
                </p>

            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/blog.js"></script>

<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://lucyyang719.com/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>

<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-104173686-1';
    var _gaDomain = 'lucyyang719.com';
    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>


<!-- Baidu Tongji -->

<script>
    var _baId = '8d7d181e1a570aab168b4b03341e12d1';
    // Originial
    var _hmt = _hmt || [];
    (function() {
        var hm = document.createElement("script");
        hm.src = "//hm.baidu.com/hm.js?" + _baId;
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>


<!-- swiftype -->
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','','2.0.0');
</script>

<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<!--wechat title img-->
<img class="wechat-title-img" src="http://lucyyang719.com/img/saberQ2.jpg"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>

</html>
